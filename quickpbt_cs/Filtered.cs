using FsCheck;
using FsCheck.Xunit;
using System;
using System.Linq;

namespace quickpbt
{
  /* domain under test */
  using Date = System.DateTimeOffset;
  using Zone = System.TimeZoneInfo;

  /// <summary>
  /// demonstrates a few different ways to filter inputs to a test
  /// </summary>
  public sealed class Filtered
  {
    private static readonly string ZoneName = Platform.As(
      win:  () => "Eastern Standard Time",
      osx:  () => "America/New_York",
      unix: () => throw new PlatformNotSupportedException()
    );

    /// <summary>
    /// naive test fails (because the range of inputs is too broad)
    /// </summary>
    [Property]
    public bool daylight_savings_test_oracle_naive(Date anyDate)
    {
      /**
        NOTE: this test also demonstrates the common pattern of the
              "test oracle" ... using a known-good implementation of
              something to test out an alternate, equivalent implementation
      */
      var eastern   = Zone.FindSystemTimeZoneById(ZoneName);
      var eastDate  = Zone.ConvertTime(anyDate, eastern);

      return ZoneUtils.InUnitedStatesDaylightTime(eastDate) == eastern.IsDaylightSavingTime(eastDate);
    }

    /// <summary>
    /// uses a conditional property to ensure only valid inputs are used
    /// </summary>
    [Property]
    public Property daylight_savings_test_oracle_conditional(Date anyDate)
    {
      var eastern   = Zone.FindSystemTimeZoneById(ZoneName);
      var eastDate  = Zone.ConvertTime(anyDate, eastern);

      bool check() => ZoneUtils.InUnitedStatesDaylightTime(eastDate) == eastern.IsDaylightSavingTime(eastDate);
      
      return check().When(anyDate.Year >= 2007 && eastern.IsDaylightSavingTime(eastDate));
    }
    
    /// <summary>
    /// instead of a conditional property, here we use a IArbitrary with a "universal quantifier"
    /// </summary>
    [Property]
    public Property zone_is_unchanged_through_round_trip_serialization()
    {
      // define a test whose inputs are NOT normally generated by FsCheck
      bool check(Zone anyZone)
      {
        if (Platform.IsWin)
        {
          var deflated = anyZone.ToSerializedString();
          var inflated = Zone.FromSerializedString(deflated);
          return anyZone.Equals(inflated);
          /**
            NOTE: this test also demonstrates another variation on the "inversion" pattern
          */
        }
        return true;
        /**
          NOTE: there is a known issue with deseriazing TimeZoneInfo on non-Windows OSes
        */
      };

      // arbitrary generators can be easily defined
      var zones = Gen.Elements(from z in Zone.GetSystemTimeZones() select z).ToArbitrary();

      // "for all" zones, run a test...
      return Prop.ForAll(zones, z => check(z)); 
    }
  }
}
